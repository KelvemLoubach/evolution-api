{"version":3,"sources":["../../../../../../src/api/integrations/channel/whatsapp/voiceCalls/useVoiceCallsBaileys.ts"],"sourcesContent":["import { ConnectionState, WAConnectionState, WASocket } from 'baileys';\r\nimport { io, Socket } from 'socket.io-client';\r\n\r\nimport { ClientToServerEvents, ServerToClientEvents } from './transport.type';\r\n\r\nlet baileys_connection_state: WAConnectionState = 'close';\r\n\r\nexport const useVoiceCallsBaileys = async (\r\n  wavoip_token: string,\r\n  baileys_sock: WASocket,\r\n  status?: WAConnectionState,\r\n  logger?: boolean,\r\n) => {\r\n  baileys_connection_state = status ?? 'close';\r\n\r\n  const socket: Socket<ServerToClientEvents, ClientToServerEvents> = io('https://devices.wavoip.com/baileys', {\r\n    transports: ['websocket'],\r\n    path: `/${wavoip_token}/websocket`,\r\n  });\r\n\r\n  socket.on('connect', () => {\r\n    if (logger) console.log('[*] - Wavoip connected', socket.id);\r\n\r\n    socket.emit(\r\n      'init',\r\n      baileys_sock.authState.creds.me,\r\n      baileys_sock.authState.creds.account,\r\n      baileys_connection_state,\r\n    );\r\n  });\r\n\r\n  socket.on('disconnect', () => {\r\n    if (logger) console.log('[*] - Wavoip disconnect');\r\n  });\r\n\r\n  socket.on('connect_error', (error) => {\r\n    if (socket.active) {\r\n      if (logger)\r\n        console.log(\r\n          '[*] - Wavoip connection error temporary failure, the socket will automatically try to reconnect',\r\n          error,\r\n        );\r\n    } else {\r\n      if (logger) console.log('[*] - Wavoip connection error', error.message);\r\n    }\r\n  });\r\n\r\n  socket.on('onWhatsApp', async (jid, callback) => {\r\n    try {\r\n      const response: any = await baileys_sock.onWhatsApp(jid);\r\n\r\n      callback(response);\r\n\r\n      if (logger) console.log('[*] Success on call onWhatsApp function', response, jid);\r\n    } catch (error) {\r\n      if (logger) console.error('[*] Error on call onWhatsApp function', error);\r\n    }\r\n  });\r\n\r\n  socket.on('profilePictureUrl', async (jid, type, timeoutMs, callback) => {\r\n    try {\r\n      const response = await baileys_sock.profilePictureUrl(jid, type, timeoutMs);\r\n\r\n      callback(response);\r\n\r\n      if (logger) console.log('[*] Success on call profilePictureUrl function', response);\r\n    } catch (error) {\r\n      if (logger) console.error('[*] Error on call profilePictureUrl function', error);\r\n    }\r\n  });\r\n\r\n  socket.on('assertSessions', async (jids, force, callback) => {\r\n    try {\r\n      const response = await baileys_sock.assertSessions(jids, force);\r\n\r\n      callback(response);\r\n\r\n      if (logger) console.log('[*] Success on call assertSessions function', response);\r\n    } catch (error) {\r\n      if (logger) console.error('[*] Error on call assertSessions function', error);\r\n    }\r\n  });\r\n\r\n  socket.on('createParticipantNodes', async (jids, message, extraAttrs, callback) => {\r\n    try {\r\n      const response = await baileys_sock.createParticipantNodes(jids, message, extraAttrs);\r\n\r\n      callback(response, true);\r\n\r\n      if (logger) console.log('[*] Success on call createParticipantNodes function', response);\r\n    } catch (error) {\r\n      if (logger) console.error('[*] Error on call createParticipantNodes function', error);\r\n    }\r\n  });\r\n\r\n  socket.on('getUSyncDevices', async (jids, useCache, ignoreZeroDevices, callback) => {\r\n    try {\r\n      const response = await baileys_sock.getUSyncDevices(jids, useCache, ignoreZeroDevices);\r\n\r\n      callback(response);\r\n\r\n      if (logger) console.log('[*] Success on call getUSyncDevices function', response);\r\n    } catch (error) {\r\n      if (logger) console.error('[*] Error on call getUSyncDevices function', error);\r\n    }\r\n  });\r\n\r\n  socket.on('generateMessageTag', async (callback) => {\r\n    try {\r\n      const response = await baileys_sock.generateMessageTag();\r\n\r\n      callback(response);\r\n\r\n      if (logger) console.log('[*] Success on call generateMessageTag function', response);\r\n    } catch (error) {\r\n      if (logger) console.error('[*] Error on call generateMessageTag function', error);\r\n    }\r\n  });\r\n\r\n  socket.on('sendNode', async (stanza, callback) => {\r\n    try {\r\n      console.log('sendNode', JSON.stringify(stanza));\r\n      const response = await baileys_sock.sendNode(stanza);\r\n\r\n      callback(true);\r\n\r\n      if (logger) console.log('[*] Success on call sendNode function', response);\r\n    } catch (error) {\r\n      if (logger) console.error('[*] Error on call sendNode function', error);\r\n    }\r\n  });\r\n\r\n  socket.on('signalRepository:decryptMessage', async (jid, type, ciphertext, callback) => {\r\n    try {\r\n      const response = await baileys_sock.signalRepository.decryptMessage({\r\n        jid: jid,\r\n        type: type,\r\n        ciphertext: ciphertext,\r\n      });\r\n\r\n      callback(response);\r\n\r\n      if (logger) console.log('[*] Success on call signalRepository:decryptMessage function', response);\r\n    } catch (error) {\r\n      if (logger) console.error('[*] Error on call signalRepository:decryptMessage function', error);\r\n    }\r\n  });\r\n\r\n  // we only use this connection data to inform the webphone that the device is connected and creeds account to generate e2e whatsapp key for make call packets\r\n  baileys_sock.ev.on('connection.update', (update: Partial<ConnectionState>) => {\r\n    const { connection } = update;\r\n\r\n    if (connection) {\r\n      baileys_connection_state = connection;\r\n      socket\r\n        .timeout(1000)\r\n        .emit(\r\n          'connection.update:status',\r\n          baileys_sock.authState.creds.me,\r\n          baileys_sock.authState.creds.account,\r\n          connection,\r\n        );\r\n    }\r\n\r\n    if (update.qr) {\r\n      socket.timeout(1000).emit('connection.update:qr', update.qr);\r\n    }\r\n  });\r\n\r\n  baileys_sock.ws.on('CB:call', (packet) => {\r\n    if (logger) console.log('[*] Signling received');\r\n    socket.volatile.timeout(1000).emit('CB:call', packet);\r\n  });\r\n\r\n  baileys_sock.ws.on('CB:ack,class:call', (packet) => {\r\n    if (logger) console.log('[*] Signling ack received');\r\n    socket.volatile.timeout(1000).emit('CB:ack,class:call', packet);\r\n  });\r\n\r\n  return socket;\r\n};\r\n"],"mappings":"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","names":["io","baileys_connection_state","useVoiceCallsBaileys","wavoip_token","baileys_sock","status","logger","socket","error","jid","callback","response","type","timeoutMs","jids","force","message","extraAttrs","useCache","ignoreZeroDevices","stanza","ciphertext","update","connection","packet"]}